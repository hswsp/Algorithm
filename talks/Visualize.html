
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Visualize your data structures! Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400,400i" rel="stylesheet"/>
    <script type="text/javascript" src="//unpkg.com/viz.js"></script>

    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../JsDemo.html" />
    
    
    <link rel="prev" href="Immutability.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Documentation</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Overview
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="../">
            
                <a href="../#features">
            
                    
                    Features
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="../">
            
                <a href="../#getting-started">
            
                    
                    Getting started
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Guide.html">
            
                <a href="../Guide.html">
            
                    
                    Guide
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Guide.html">
            
                <a href="../Guide.html#trees">
            
                    
                    Trees
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Guide.html">
            
                <a href="../Guide.html#renderers">
            
                    
                    Renderers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Guide.html">
            
                <a href="../Guide.html#diagrams">
            
                    
                    Diagrams
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Guide.html">
            
                <a href="../Guide.html#animations">
            
                    
                    Animations
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <a target="_blank" href="https://stanch.github.io/reftree/api/jvm/index.html">
            
                    
                    Scala API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <a target="_blank" href="https://stanch.github.io/reftree/api/js/index.html">
            
                    
                    Scala.js API
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Useful links</li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <a target="_blank" href="https://github.com/stanch/reftree">
            
                    
                    GitHub page
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" >
            
                <a target="_blank" href="https://gitter.im/stanch/reftree">
            
                    
                    Gitter chat
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Talks & demos</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../Talks.html">
            
                <a href="../Talks.html">
            
                    
                    Talks
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="Immutability.html">
            
                <a href="Immutability.html">
            
                    
                    Unzipping immutability
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.1.2" data-path="Visualize.html">
            
                <a href="Visualize.html">
            
                    
                    Visualize your data structures!
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../JsDemo.html">
            
                <a href="../JsDemo.html">
            
                    
                    Scala.js demo
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Visualize your data structures!</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="visualize-your-data-structures">Visualize your data structures!</h1>
<p>This page contains the materials for my talk &#x201C;Visualize your data structures!&#x201D;.
Here are some past and future presentations:</p>
<ul>
<li><a href="http://event.scaladays.org/scaladays-chicago-2017#!#schedulePopupExtras-8067" target="_blank">ScalaDays Chicago, April 2017</a> (<a href="https://www.youtube.com/watch?v=6mWaqGHeg3g" target="_blank">video</a>).</li>
<li><a href="http://scala-swarm.org/" target="_blank">Scala Swarm, June 2017</a>.</li>
</ul>
<p>You can use this page in two ways:</p>
<ul>
<li>as a reference/refresher on the material covered in the talk;</li>
<li>as an interactive playground where you can try the same commands I presented.</li>
</ul>
<p>Here is an overview:</p>
<ul>
<li><a href="#introducing-reftree">Introducing <code>reftree</code></a></li>
<li><a href="#inside-reftree">Inside <code>reftree</code></a></li>
<li><a href="#functional-animation">Functional animation</a></li>
<li><a href="#zipping-it-up">Zipping it up</a></li>
</ul>
<p>Throughout this page we will assume the following
declarations (each section might add its own):</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> reftree.core._
<span class="hljs-keyword">import</span> reftree.diagram._
<span class="hljs-keyword">import</span> reftree.render._
<span class="hljs-keyword">import</span> reftree.geometry._
<span class="hljs-keyword">import</span> reftree.svg.animation.<span class="hljs-type">Frame</span>
<span class="hljs-keyword">import</span> reftree.svg.<span class="hljs-type">XmlSvgApi</span>
<span class="hljs-keyword">import</span> reftree.svg.<span class="hljs-type">XmlSvgApi</span>.svgUnzip
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">XmlInstances</span>._
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">OpticInstances</span>._
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">ZipperInstances</span>._
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">ShapelessInstances</span>._
<span class="hljs-keyword">import</span> reftree.util.<span class="hljs-type">Optics</span>
<span class="hljs-keyword">import</span> reftree.demo.<span class="hljs-type">Data</span>
<span class="hljs-keyword">import</span> reftree.demo.<span class="hljs-type">Shortcuts</span>
<span class="hljs-keyword">import</span> scala.collection.immutable._
<span class="hljs-keyword">import</span> java.nio.file.<span class="hljs-type">Paths</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">Diagram</span>.{sourceCodeCaption &#x21D2; diagram}
</code></pre>
<p>To start an interactive session, just run</p>
<pre><code>$ sbt demo
@ render(List(1, 2, 3))
</code></pre><p>and open <code>diagram.png</code> in your favorite image viewer (hopefully one that
reloads images automatically on file change). You will also need to have
<a href="http://www.graphviz.org/" target="_blank">GraphViz</a> installed. <em>The interactive session
already has all the necessary imports in scope.</em></p>
<h2 id="introducing-reftree">Introducing <code>reftree</code></h2>
<pre><code class="lang-scala"><span class="hljs-comment">// extra declarations for this section</span>
<span class="hljs-keyword">val</span> renderer = <span class="hljs-type">Renderer</span>(
  renderingOptions = <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">75</span>),
  directory = <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;visualize&quot;</span>, <span class="hljs-string">&quot;intro&quot;</span>)
)
<span class="hljs-keyword">import</span> renderer._
</code></pre>
<p><a href="https://stanch.github.io/reftree" target="_blank">reftree</a> is a library for visualizing Scala data structures.</p>
<p>Let&#x2019;s look at a quick usage example:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span>
defined <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>

scala&gt; <span class="hljs-keyword">val</span> bob = <span class="hljs-type">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">42</span>)
bob: <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span>(<span class="hljs-type">Bob</span>,<span class="hljs-number">42</span>)

scala&gt; diagram(bob).render(<span class="hljs-string">&quot;bob&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/intro/bob.png" alt="bob"></div></p>
<p>That&#x2019;s it! You can configure the visualization as you like:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-comment">// render strings as a single box</span>
     | <span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">SimplifiedInstances</span>.string
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">SimplifiedInstances</span>.string

scala&gt; <span class="hljs-comment">// rename the firstName field (pun not intended)</span>
     | <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> personConfig = (<span class="hljs-type">ToRefTree</span>.<span class="hljs-type">DerivationConfig</span>[<span class="hljs-type">Person</span>]
     |   .tweakField(<span class="hljs-string">&quot;firstName&quot;</span>, _.withName(<span class="hljs-string">&quot;name&quot;</span>)))
personConfig: reftree.core.<span class="hljs-type">ToRefTree</span>.<span class="hljs-type">DerivationConfig</span>[<span class="hljs-type">Person</span>] = <span class="hljs-type">DerivationConfig</span>(<span class="hljs-type">None</span>,<span class="hljs-type">Set</span>(),<span class="hljs-type">Map</span>(firstName -&gt; &lt;function1&gt;))

scala&gt; diagram(bob).render(<span class="hljs-string">&quot;bob-simplified&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/intro/bob-simplified.png" alt="bob-simplified"></div></p>
<p>There are various ways you can use <code>reftree</code>:</p>
<ul>
<li>improving the documentation of your projects;</li>
<li>live-coding demos;</li>
<li>exploring how things work;</li>
<li>anywhere you need diagrams of your Scala data structures.</li>
</ul>
<p>(<em>Incidentally, this talk is an example of all of the above.</em>)</p>
<p>My previous <code>reftree</code>-powered <a href="Immutability.html">talk</a> focused on
immutable data and various ways it can be manipulated (I do recommend it).</p>
<p>Today I would like to take you on a journey deep inside <code>reftree</code> itself,
so that we can see how some of these techniques and concepts can be applied...
to produce visualizations of themselves &#x2014; using one of my favorite <code>reftree</code>
features: animations.</p>
<pre><code class="lang-scala"><span class="hljs-type">Animation</span>
  .startWith(<span class="hljs-type">Queue</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
  .repeat(<span class="hljs-number">3</span>)(_.iterate(<span class="hljs-number">2</span>)(q &#x21D2; q :+ (q.max + <span class="hljs-number">1</span>)).iterate(<span class="hljs-number">2</span>)(_.tail))
  .build(<span class="hljs-type">Diagram</span>.toStringCaption(_).withAnchor(<span class="hljs-string">&quot;queue&quot;</span>))
  .render(<span class="hljs-string">&quot;queue&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/queue.gif" alt="queue"></div></p>
<h2 id="inside-reftree">Inside <code>reftree</code></h2>
<pre><code class="lang-scala"><span class="hljs-comment">// extra declarations for this section</span>
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">SimplifiedInstances</span>.{option, seq, list}

<span class="hljs-keyword">val</span> renderer = <span class="hljs-type">Renderer</span>(
  renderingOptions = <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">75</span>),
  directory = <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;visualize&quot;</span>, <span class="hljs-string">&quot;inside&quot;</span>)
)
<span class="hljs-keyword">import</span> renderer._
</code></pre>
<p>First, we need to grasp the basics of <code>reftree</code>.</p>
<p>To visualize a value of some type <code>A</code>, <code>reftree</code> converts it into a data structure
called <code>RefTree</code> (surprise!), using a typeclass <code>ToRefTree[A]</code>.</p>
<p>For case classes this is done automagically, using
<a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#generic-representation-of-sealed-families-of-case-classes" target="_blank"><em>shapeless</em></a>.
(<em>If you are curious about the magic, take a look at <a href="https://github.com/stanch/reftree/blob/master/core/shared/src/main/scala/reftree/core/GenericInstances.scala" target="_blank">this file</a>.</em>)
Given our friend <code>bob</code>, <em>shapeless</em> would provide a generic representation,
which includes the field names (at the type level!) and the values (as a heterogeneous list):</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-type">Shortcuts</span>.generic(bob)
res7: shapeless.::[<span class="hljs-type">String</span> <span class="hljs-keyword">with</span> shapeless.labelled.<span class="hljs-type">KeyTag</span>[<span class="hljs-type">Symbol</span> <span class="hljs-keyword">with</span> shapeless.tag.<span class="hljs-type">Tagged</span>[<span class="hljs-type">String</span>(<span class="hljs-string">&quot;firstName&quot;</span>)],<span class="hljs-type">String</span>],shapeless.::[<span class="hljs-type">Int</span> <span class="hljs-keyword">with</span> shapeless.labelled.<span class="hljs-type">KeyTag</span>[<span class="hljs-type">Symbol</span> <span class="hljs-keyword">with</span> shapeless.tag.<span class="hljs-type">Tagged</span>[<span class="hljs-type">String</span>(<span class="hljs-string">&quot;age&quot;</span>)],<span class="hljs-type">Int</span>],shapeless.<span class="hljs-type">HNil</span>]] = <span class="hljs-type">Bob</span> :: <span class="hljs-number">42</span> :: <span class="hljs-type">HNil</span>

scala&gt; diagram(<span class="hljs-type">Shortcuts</span>.generic(bob)).render(<span class="hljs-string">&quot;generic&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/inside/generic.png" alt="generic"></div></p>
<p>This information is enough to auto-generate a <code>RefTree</code>.
Now, what does it look like? The best way to find out is to visualize a <code>RefTree</code>
of a <code>RefTree</code>!</p>
<pre><code class="lang-scala">scala&gt; diagram(<span class="hljs-type">Shortcuts</span>.refTree(bob)).render(<span class="hljs-string">&quot;reftree&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/inside/reftree.png" alt="reftree"></div></p>
<p>As you can see, it contains values (<code>Val</code>) and references (<code>Ref</code>).</p>
<p>How do we get from <code>RefTree</code> to an image though?
This is where <a href="http://www.graphviz.org/" target="_blank">GraphViz</a> comes in.
From a <code>RefTree</code> we can obtain a graph definition that can be rendered by GraphViz:</p>
<pre><code class="lang-scala">scala&gt; Shortcuts.graph(bob).encode
res10: String =
digraph &quot;Diagram&quot; {
  graph [ ranksep=0.8 bgcolor=&quot;#ffffff00&quot; ]
  node [ shape=&quot;plaintext&quot; fontname=&quot;Source Code Pro&quot; fontcolor=&quot;#000000ff&quot; ]
  edge [ arrowsize=0.7 color=&quot;#000000ff&quot; ]
  &quot;-Person599628537&quot; [ id=&quot;-Person599628537&quot; label=&lt;&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;6&quot; cellborder=&quot;0&quot; columns=&quot;*&quot; bgcolor=&quot;#ffffff00&quot; style=&quot;rounded&quot;&gt;&lt;tr&gt;&lt;td port=&quot;n&quot; rowspan=&quot;2&quot;&gt;Person&lt;/td&gt;&lt;td bgcolor=&quot;#ffffff00&quot;&gt;&lt;i&gt;name&lt;/i&gt;&lt;/td&gt;&lt;td bgcolor=&quot;#ffffff00&quot;&gt;&lt;i&gt;age&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&lt;hr/&gt;&lt;tr&gt;&lt;td port=&quot;0&quot; bgcolor=&quot;#ffffff00&quot;&gt;&amp;middot;&lt;/td&gt;&lt;td bgcolor=&quot;#ffffff00&quot;&gt;42&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt; ] [ color=&quot;#104e8bff&quot; fontcolor=&quot;#104e8bff&quot; ]
  &quot;-java.lang.String1108513508&quot; [ id=&quot;-java.lang.String1108513508&quot; label=&lt;&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;6&quot; cellborder=&quot;0&quot; columns=&quot;*&quot; bgcolor=&quot;#ffffff00&quot; style=&quot;roun...
</code></pre>
<p>Going even further, we can ask GraphViz for an <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" target="_blank">SVG</a> output:</p>
<pre><code class="lang-scala">scala&gt; Shortcuts.svg(bob)
res11: scala.xml.Node = &lt;svg viewBox=&quot;0.00 0.00 171.00 168.00&quot; height=&quot;168pt&quot; width=&quot;171pt&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;g class=&quot;graph&quot; id=&quot;graph0&quot;&gt;&lt;title&gt;Diagram&lt;/title&gt;&lt;polygon points=&quot;-4,4 -4,-164 167,-164 167,4 -4,4&quot; stroke=&quot;none&quot; fill=&quot;none&quot;/&gt;&lt;g class=&quot;node&quot; id=&quot;-Person599628537&quot;&gt;&lt;title&gt;-Person599628537&lt;/title&gt;&lt;path d=&quot;M20,-100C20,-100 143,-100 143,-100 149,-100 155,-106 155,-112 155,-112 155,-144 155,-144 155,-150 149,-156 143,-156 143,-156 20,-156 20,-156 14,-156 8,-150 8,-144 8,-144 8,-112 8,-112 8,-106 14,-100 20,-100&quot; stroke=&quot;none&quot; fill=&quot;none&quot;/&gt;&lt;text fill=&quot;#104e8b&quot; font-size=&quot;14.00&quot; font-family=&quot;Source Code Pro&quot; y=&quot;-124.3&quot; x=&quot;15.5&quot; text-anchor=&quot;start&quot;&gt;Person&lt;/text&gt;&lt;polygon points=&quot;71.5,-128 71.5,-155 117.5,-155 117.5,-128 71.5...
</code></pre>
<p>At this point you might be guessing how we can use this as a basis for our animation approach.
Every state of a data structure will be a separate frame in the SVG format.
However, an animation consisting of these frames alone would be too jumpy.
We need to add intermediate frames to smoothly &#x201C;morph&#x201D; one frame into another.
With SVG being a vector format, this sounds simple.
We just have to individually morph different aspects of the image:</p>
<ul>
<li>graph node positions;</li>
<li>graph edges and their shapes;</li>
<li>colors;</li>
<li>stroke thickness;</li>
<li>transparency.</li>
</ul>
<p>Ouch! A sane functional approach would definitely help here :)</p>
<h2 id="functional-animation">Functional animation</h2>
<pre><code class="lang-scala"><span class="hljs-comment">// extra declarations for this section</span>
<span class="hljs-keyword">val</span> renderer = <span class="hljs-type">Renderer</span>(
  renderingOptions = <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">75</span>),
  directory = <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;visualize&quot;</span>, <span class="hljs-string">&quot;animation&quot;</span>)
)
<span class="hljs-keyword">import</span> renderer._
</code></pre>
<p>Let&#x2019;s start by introducing an abstraction for morphing, or, in other words,
interpolating things of type <code>A</code>:</p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Interpolation</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(left: <span class="hljs-type">A</span>, right: <span class="hljs-type">A</span>, time: <span class="hljs-type">Double</span>): <span class="hljs-type">A</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sample</span></span>(left: <span class="hljs-type">A</span>, right: <span class="hljs-type">A</span>, n: <span class="hljs-type">Int</span>, inclusive: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>): <span class="hljs-type">Seq</span>[<span class="hljs-type">A</span>]
}
</code></pre>
<p>(<em>If you are curious, <a href="https://github.com/stanch/reftree/blob/master/core/shared/src/main/scala/reftree/geometry/Interpolation.scala" target="_blank">here is the actual implementation</a>.</em>)</p>
<p>Once we have an instance of <code>Interpolation[xml.Node]</code>, we can generate
as many intermediate frames as we want! But how do we construct this instance?</p>
<p>Consider a lowly floating point number (it can represent an <em>x</em> coordinate of some element in our SVG, for example).
There is an obvious way to implement <code>Interpolation[Double]</code>, which <code>reftree</code> already defines as <code>Interpolation.double</code>:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> numbers = <span class="hljs-type">Interpolation</span>.double.sample(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>).toList
numbers: <span class="hljs-type">List</span>[<span class="hljs-type">Double</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">7.5</span>, <span class="hljs-number">10.0</span>)

scala&gt; diagram(numbers).render(<span class="hljs-string">&quot;numbers&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/numbers.png" alt="numbers"></div></p>
<p>Now if you think about a point in 2D space, it&#x2019;s just two numbers joined together:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> point = <span class="hljs-type">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
point: reftree.geometry.<span class="hljs-type">Point</span> = <span class="hljs-number">0.0</span> <span class="hljs-number">10.0</span>

scala&gt; diagram(point).render(<span class="hljs-string">&quot;point&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/point.png" alt="point"></div></p>
<p>Can we use the number interpolation to interpolate these two numbers?
To answer this question, let&#x2019;s introduce more abstraction
(in a great tradition of functional programming).</p>
<p>A lens <code>Lens[A, B]</code> is something that can &#x201C;focus&#x201D; on a piece of data of type <code>B</code>
inside a data structure of type <code>A</code> and provide read-write access to it.
We will use the excellent <a href="https://github.com/julien-truffaut/Monocle" target="_blank"><em>Monocle</em> library</a>
to create lenses and other optics along the way:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">GenLens</span>
<span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">GenLens</span>

scala&gt; <span class="hljs-keyword">val</span> x = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Point</span>](_.x)
x: monocle.<span class="hljs-type">Lens</span>[reftree.geometry.<span class="hljs-type">Point</span>,<span class="hljs-type">Double</span>] = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">3</span>cadee74

scala&gt; <span class="hljs-keyword">val</span> y = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Point</span>](_.y)
y: monocle.<span class="hljs-type">Lens</span>[reftree.geometry.<span class="hljs-type">Point</span>,<span class="hljs-type">Double</span>] = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">5633</span>c31c

scala&gt; (diagram(<span class="hljs-type">OpticFocus</span>(x, point)).toNamespace(<span class="hljs-string">&quot;x&quot;</span>) +
     |   diagram(<span class="hljs-type">OpticFocus</span>(y, point)).toNamespace(<span class="hljs-string">&quot;y&quot;</span>)).render(<span class="hljs-string">&quot;x+y&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/x+y.png" alt="x+y"></div></p>
<p>Lenses provide several methods to manipulate data:</p>
<pre><code class="lang-scala">scala&gt; x.get(point)
res16: <span class="hljs-type">Double</span> = <span class="hljs-number">0.0</span>

scala&gt; y.set(<span class="hljs-number">20</span>)(point)
res17: reftree.geometry.<span class="hljs-type">Point</span> = <span class="hljs-number">0.0</span> <span class="hljs-number">20.0</span>

scala&gt; y.modify(_ + <span class="hljs-number">20</span>)(point)
res18: reftree.geometry.<span class="hljs-type">Point</span> = <span class="hljs-number">0.0</span> <span class="hljs-number">30.0</span>
</code></pre>
<p>If we can read and write each coordinate field, we can interpolate them separately
and update the point field by field.
We do this by piping <code>Interpolation.double</code> through <code>x</code> and <code>y</code> lenses
and combining the resulting interpolations:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> pointInterpolation = (
     |   x.interpolateWith(<span class="hljs-type">Interpolation</span>.double) +
     |   y.interpolateWith(<span class="hljs-type">Interpolation</span>.double))
pointInterpolation: reftree.geometry.<span class="hljs-type">Interpolation</span>[reftree.geometry.<span class="hljs-type">Point</span>] = reftree.geometry.<span class="hljs-type">Interpolation</span>$$anon$<span class="hljs-number">2</span>@<span class="hljs-number">6e540</span>a37

scala&gt; <span class="hljs-keyword">val</span> points = pointInterpolation.sample(<span class="hljs-type">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-type">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>), <span class="hljs-number">5</span>).toList
points: <span class="hljs-type">List</span>[reftree.geometry.<span class="hljs-type">Point</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">0.0</span> <span class="hljs-number">0.0</span>, <span class="hljs-number">2.5</span> <span class="hljs-number">5.0</span>, <span class="hljs-number">5.0</span> <span class="hljs-number">10.0</span>, <span class="hljs-number">7.5</span> <span class="hljs-number">15.0</span>, <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span>)

scala&gt; diagram(points).render(<span class="hljs-string">&quot;points&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/points.png" alt="points"></div></p>
<p>Of course, <code>reftree</code> already defines this as <code>Point.interpolation</code>.</p>
<p>Using the same approach, we can build a polyline interpolator
(assuming the polylines being interpolated consist of equal number of points):</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-type">Data</span>.polyline1
res20: reftree.geometry.<span class="hljs-type">Polyline</span> = <span class="hljs-number">0.0</span> <span class="hljs-number">10.0</span>,<span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span>

scala&gt; <span class="hljs-type">Data</span>.polyline2
res21: reftree.geometry.<span class="hljs-type">Polyline</span> = <span class="hljs-number">20.0</span> <span class="hljs-number">30.0</span>,<span class="hljs-number">40.0</span> <span class="hljs-number">50.0</span>

scala&gt; <span class="hljs-keyword">val</span> polylineInterpolation = (<span class="hljs-type">GenLens</span>[<span class="hljs-type">Polyline</span>](_.points)
     |   .interpolateEachWith(<span class="hljs-type">Point</span>.interpolation))
polylineInterpolation: reftree.geometry.<span class="hljs-type">Interpolation</span>[reftree.geometry.<span class="hljs-type">Polyline</span>] = reftree.geometry.<span class="hljs-type">Interpolation</span>$$anon$<span class="hljs-number">2</span><span class="hljs-meta">@b</span>392277

scala&gt; <span class="hljs-keyword">val</span> polylines = polylineInterpolation.sample(<span class="hljs-type">Data</span>.polyline1, <span class="hljs-type">Data</span>.polyline2, <span class="hljs-number">3</span>).toList
polylines: <span class="hljs-type">List</span>[reftree.geometry.<span class="hljs-type">Polyline</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">0.0</span> <span class="hljs-number">10.0</span>,<span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span>, <span class="hljs-number">10.0</span> <span class="hljs-number">20.0</span>,<span class="hljs-number">25.0</span> <span class="hljs-number">35.0</span>, <span class="hljs-number">20.0</span> <span class="hljs-number">30.0</span>,<span class="hljs-number">40.0</span> <span class="hljs-number">50.0</span>)

scala&gt; diagram(polylines).render(<span class="hljs-string">&quot;polylines&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/polylines.png" alt="polylines"></div></p>
<p>We are finally ready to implement our first substantial interpolator: one that morphs graph edges.
<em>The following approach is inspired by Mike Bostock&#x2019;s <a href="https://bl.ocks.org/mbostock/3916621" target="_blank">path tween</a>,
however <code>reftree</code> puts more emphasis on types and even includes its own
<a href="https://github.com/stanch/reftree/blob/master/core/shared/src/main/scala/reftree/geometry/Path.scala" target="_blank">SVG path parser and simplification algorithm</a>.</em></p>
<p>The resulting animation should look like this:</p>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edges-100.gif" alt="edges-100"></div></p>
<p>An edge is drawn with an <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths" target="_blank">SVG path</a>,
which consists of several commands, e.g. &#x201C;move to&#x201D;, &#x201C;line to&#x201D;, &#x201C;bezier curve to&#x201D;.
Here is a minimized SVG snippet for an actual edge:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-type">Data</span>.edge1
res23: scala.xml.<span class="hljs-type">Node</span> = &lt;svg viewBox=<span class="hljs-string">&quot;50 -200 130 70&quot;</span> height=<span class="hljs-string">&quot;70pt&quot;</span> width=<span class="hljs-string">&quot;130pt&quot;</span> shape-rendering=<span class="hljs-string">&quot;geometricPrecision&quot;</span> xmlns=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span> xmlns:xlink=<span class="hljs-string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;&lt;g <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;edge&quot;</span>&gt;&lt;path d=<span class="hljs-string">&quot;M84.5,-195C84.5,-165.869 62.5907,-160.925 58.9962,-135.762&quot;</span> stroke=<span class="hljs-string">&quot;#104e8b&quot;</span> fill=<span class="hljs-string">&quot;none&quot;</span>/&gt;&lt;/g&gt;&lt;/svg&gt;

scala&gt; diagram(<span class="hljs-type">Data</span>.edge1).render(<span class="hljs-string">&quot;edge&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edge.png" alt="edge"></div></p>
<p>As you can see, the commands themselves are given in the <code>d</code> attribute inside the <code>path</code> element
in a rather obscure format. Luckily, we have lenses and other optics at our disposal
to plumb through this mess.</p>
<p>First, let&#x2019;s get to the <code>path</code> element. <code>reftree</code> implements a few things that will help us:</p>
<ul>
<li><code>XmlSvgApi</code>, an implementation of several useful SVG operations for <em>scala-xml</em>.
In particular, if offers a CSS selector-like method for matching elements of certain type and/or class.</li>
<li>An optic that focuses on an element deep inside XML or any other recursive data structure: <code>Optics.collectFirst</code>.
It is actually an <code>Optional</code>, not a <code>Lens</code>, since the element might be missing.</li>
</ul>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> edgePathElement = <span class="hljs-type">Optics</span>.collectFirst(<span class="hljs-type">XmlSvgApi</span>.select(<span class="hljs-string">&quot;path&quot;</span>))
edgePathElement: monocle.<span class="hljs-type">Optional</span>[scala.xml.<span class="hljs-type">Node</span>,scala.xml.<span class="hljs-type">Node</span>] = monocle.<span class="hljs-type">Optional</span>$$anon$<span class="hljs-number">6</span><span class="hljs-meta">@ed</span>4aed8

scala&gt; diagram(<span class="hljs-type">OpticFocus</span>(edgePathElement, <span class="hljs-type">Data</span>.edge1)).render(<span class="hljs-string">&quot;edgePathElement&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edgePathElement.png" alt="edgePathElement"></div></p>
<p>Next, we need to &#x201C;descend&#x201D; to the <code>d</code> attribute. Here is where optics really shine:
we can compose <code>Optional[A, B]</code> with <code>Optional[B, C]</code> to get an <code>Optional[A, C]</code>:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> d = <span class="hljs-type">XmlSvgApi</span>.attr(<span class="hljs-string">&quot;d&quot;</span>)
d: monocle.<span class="hljs-type">Optional</span>[scala.xml.<span class="hljs-type">Node</span>,<span class="hljs-type">String</span>] = monocle.<span class="hljs-type">POptional</span>$$anon$<span class="hljs-number">1</span>@<span class="hljs-number">5</span>c973321

scala&gt; <span class="hljs-keyword">val</span> edgePathString = edgePathElement composeOptional d
edgePathString: monocle.<span class="hljs-type">POptional</span>[scala.xml.<span class="hljs-type">Node</span>,scala.xml.<span class="hljs-type">Node</span>,<span class="hljs-type">String</span>,<span class="hljs-type">String</span>] = monocle.<span class="hljs-type">POptional</span>$$anon$<span class="hljs-number">1</span>@<span class="hljs-number">2</span>d637ef1

scala&gt; diagram(<span class="hljs-type">OpticFocus</span>(edgePathString, <span class="hljs-type">Data</span>.edge1)).render(<span class="hljs-string">&quot;edgePathString&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edgePathString.png" alt="edgePathString"></div></p>
<p>Next, we will use an isomorphism, another kind of optic, to view
the string as a nice case class:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-type">Path</span>.stringIso
res27: monocle.<span class="hljs-type">Iso</span>[<span class="hljs-type">String</span>,reftree.geometry.<span class="hljs-type">Path</span>] = monocle.<span class="hljs-type">PIso</span>$$anon$<span class="hljs-number">10</span>@<span class="hljs-number">123706</span>aa

scala&gt; <span class="hljs-keyword">val</span> edgePath = edgePathString composeIso <span class="hljs-type">Path</span>.stringIso
edgePath: monocle.<span class="hljs-type">POptional</span>[scala.xml.<span class="hljs-type">Node</span>,scala.xml.<span class="hljs-type">Node</span>,reftree.geometry.<span class="hljs-type">Path</span>,reftree.geometry.<span class="hljs-type">Path</span>] = monocle.<span class="hljs-type">POptional</span>$$anon$<span class="hljs-number">1</span>@<span class="hljs-number">606</span>f998f

scala&gt; diagram(edgePath.getOption(<span class="hljs-type">Data</span>.edge1)).render(<span class="hljs-string">&quot;edgePath&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edgePath.png" alt="edgePath"></div></p>
<p>And finally, another isomorphism takes us from a <code>Path</code> to its sampled representation
as a <code>Polyline</code>. (<em>Purists will say that this is not really an isomorphism because
it&#x2019;s not reversible, but with a lot of points you can get pretty close ;)</em>)</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-type">Path</span>.polylineIso(points = <span class="hljs-number">4</span>)
res29: monocle.<span class="hljs-type">Iso</span>[reftree.geometry.<span class="hljs-type">Path</span>,reftree.geometry.<span class="hljs-type">Polyline</span>] = monocle.<span class="hljs-type">PIso</span>$$anon$<span class="hljs-number">10</span>@<span class="hljs-number">6</span>c863ee1

scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edgePolyline</span></span>(points: <span class="hljs-type">Int</span>) = edgePath composeIso <span class="hljs-type">Path</span>.polylineIso(points)
edgePolyline: (points: <span class="hljs-type">Int</span>)monocle.<span class="hljs-type">POptional</span>[scala.xml.<span class="hljs-type">Node</span>,scala.xml.<span class="hljs-type">Node</span>,reftree.geometry.<span class="hljs-type">Polyline</span>,reftree.geometry.<span class="hljs-type">Polyline</span>]

scala&gt; diagram(edgePolyline(<span class="hljs-number">4</span>).getOption(<span class="hljs-type">Data</span>.edge1)).render(<span class="hljs-string">&quot;edgePolyline&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edgePolyline.png" alt="edgePolyline"></div></p>
<p>Let&#x2019;s interpolate!</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edgeInterpolation</span></span>(points: <span class="hljs-type">Int</span>) = edgePolyline(points).interpolateWith(<span class="hljs-type">Polyline</span>.interpolation)
edgeInterpolation: (points: <span class="hljs-type">Int</span>)reftree.geometry.<span class="hljs-type">Interpolation</span>[scala.xml.<span class="hljs-type">Node</span>]

scala&gt; <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edges</span></span>(points: <span class="hljs-type">Int</span>, frames: <span class="hljs-type">Int</span>) = (<span class="hljs-type">Data</span>.edge1 +:
     |   edgeInterpolation(points).sample(<span class="hljs-type">Data</span>.edge1, <span class="hljs-type">Data</span>.edge2, frames, inclusive = <span class="hljs-literal">false</span>) :+
     |   <span class="hljs-type">Data</span>.edge2)
edges: (points: <span class="hljs-type">Int</span>, frames: <span class="hljs-type">Int</span>)scala.collection.immutable.<span class="hljs-type">Stream</span>[scala.xml.<span class="hljs-type">Node</span>]

scala&gt; <span class="hljs-type">AnimatedGifRenderer</span>.renderFrames(
     |   edges(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>).map(<span class="hljs-type">Frame</span>(_)),
     |   <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;visualize&quot;</span>, <span class="hljs-string">&quot;animation&quot;</span>, <span class="hljs-string">&quot;edges-4.gif&quot;</span>),
     |   <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">200</span>),
     |   <span class="hljs-type">AnimationOptions</span>(framesPerSecond = <span class="hljs-number">1</span>)
     | )

scala&gt; <span class="hljs-type">AnimatedGifRenderer</span>.renderFrames(
     |   edges(<span class="hljs-number">100</span>, <span class="hljs-number">32</span>).map(<span class="hljs-type">Frame</span>(_)),
     |   <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;visualize&quot;</span>, <span class="hljs-string">&quot;animation&quot;</span>, <span class="hljs-string">&quot;edges-100.gif&quot;</span>),
     |   <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">200</span>),
     |   <span class="hljs-type">AnimationOptions</span>(framesPerSecond = <span class="hljs-number">8</span>)
     | )
</code></pre>
<p>With 4 points and 4 frames:</p>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edges-4.gif" alt="edges-4"></div></p>
<p>With 100 points and 32 frames:</p>
<p><div class="image-wrapper"><img src="../images/visualize/animation/edges-100.gif" alt="edges-100"></div></p>
<p><em>Interpolating the entire image is left as an exercise for the reader,
although the impatient will find the complete implementation
<a href="https://github.com/stanch/reftree/blob/master/core/shared/src/main/scala/reftree/svg/animation/GraphInterpolation.scala" target="_blank">here</a>.</em></p>
<p>Notice that we never touched XML directly.
In fact, equipped with the same set of optics for another format or representation,
we would be able to operate on it without changing the code too much.
Case in point: <code>reftree</code> supports both
<a href="https://github.com/stanch/reftree/blob/master/core/jvm/src/main/scala/reftree/svg/XmlSvgApi.scala" target="_blank"><em>scala-xml</em></a> and
<a href="https://github.com/stanch/reftree/blob/master/core/js/src/main/scala/reftree/svg/DomSvgApi.scala" target="_blank"><em>scala-js-dom</em></a> (for Scala.js),
with only 50 lines of implementation-specific code for each backend.
This goes to show the flexibility and usefulness of optics.</p>
<h2 id="zipping-it-up">Zipping it up</h2>
<pre><code class="lang-scala"><span class="hljs-comment">// extra declarations for this section</span>
<span class="hljs-keyword">val</span> renderer = <span class="hljs-type">Renderer</span>(
  renderingOptions = <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">75</span>),
  directory = <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;visualize&quot;</span>, <span class="hljs-string">&quot;zippers&quot;</span>)
)
<span class="hljs-keyword">import</span> renderer._
</code></pre>
<p>In the previous section we saw <code>Optics.collectFirst</code> &#x2014; an optic that is able to perform
modifications deep inside SVG. How do we go about implementing something like this,
or, more generally, how do we edit recursive data structures such as XML?</p>
<p>This solution is called a &#x201C;Zipper&#x201D;, and was introduced by G&#xE9;rard Huet in 1997.
It consists of a &#x201C;cursor&#x201D; pointing to a location anywhere in a tree &#x2014; &#x201C;current focus&#x201D;.
The cursor can be moved freely with operations like <code>moveDownLeft</code>, <code>moveRight</code>, <code>moveUp</code>, etc.
Current focus can be updated, deleted, or new nodes can be inserted to its left or right.
Zippers are immutable, and every operation returns a new Zipper.
All the changes made to the tree can be committed, yielding a new modified version of the original tree.</p>
<p>My <a href="https://github.com/stanch/zipper#zipper--an-implementation-of-huets-zipper" target="_blank">zipper library</a>
provides a few useful movements and operations. Just like optics, it&#x2019;s rather generic and flexible.
The zipper can operate on any type, as long as an instance of the <code>Unzip</code> typeclass is available,
which can be automatically derived in many cases.
(<em>Note that the derivation of <code>Unzip</code> for SVG can be found
<a href="https://github.com/stanch/reftree/blob/master/core/shared/src/main/scala/reftree/svg/api/BaseSvgApi.scala" target="_blank">here</a>.</em>)</p>
<p>Consider a simple XML tree:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-type">Data</span>.simpleXml
res34: scala.xml.<span class="hljs-type">Node</span> = &lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;&lt;/tree&gt;

scala&gt; diagram(<span class="hljs-type">Data</span>.simpleXml).render(<span class="hljs-string">&quot;simpleXml&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/simpleXml.png" alt="simpleXml"></div></p>
<p>When we wrap a Zipper around this tree, it does not look very interesting yet:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">import</span> zipper.<span class="hljs-type">Zipper</span>
<span class="hljs-keyword">import</span> zipper.<span class="hljs-type">Zipper</span>

scala&gt; <span class="hljs-keyword">val</span> zipper1 = <span class="hljs-type">Zipper</span>(<span class="hljs-type">Data</span>.simpleXml)
zipper1: zipper.<span class="hljs-type">Zipper</span>[scala.xml.<span class="hljs-type">Node</span>] = <span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(),&lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;&lt;/tree&gt;,<span class="hljs-type">List</span>(),<span class="hljs-type">None</span>)

scala&gt; (diagram(<span class="hljs-type">Data</span>.simpleXml) + diagram(zipper1)).render(<span class="hljs-string">&quot;zipper1&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/zipper1.png" alt="zipper1"></div></p>
<p>We can see that it just points to the original tree.
In this case the focus is the root of the tree, which has no siblings,
and the parent zipper does not exist, since we are at the top level.</p>
<p>To move down the tree, we &#x201C;unzip&#x201D; it, separating the child nodes into
the focused node and its left and right siblings:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> zipper2 = zipper1.moveDownLeft
zipper2: zipper.<span class="hljs-type">Zipper</span>[scala.xml.<span class="hljs-type">Node</span>] = <span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(),&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;,<span class="hljs-type">List</span>(&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;, &lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;, &lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;),<span class="hljs-type">Some</span>(<span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(),&lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;&lt;/tree&gt;,<span class="hljs-type">List</span>(),<span class="hljs-type">None</span>)))

scala&gt; (diagram(zipper1) + diagram(zipper2)).render(<span class="hljs-string">&quot;zipper1+2&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/zipper1+2.png" alt="zipper1+2"></div></p>
<p>The new Zipper links to the old one,
which will allow us to return to the root of the tree when we are done applying changes.
This link however prevents us from seeing the picture clearly.
Let&#x2019;s look at the second zipper alone:</p>
<pre><code class="lang-scala">scala&gt; diagram(zipper2).render(<span class="hljs-string">&quot;zipper2b&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/zipper2b.png" alt="zipper2b"></div></p>
<p>Great! We have <code>2</code> in focus and <code>3, 4, 5</code> as right siblings. What happens if we move right a bit?</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> zipper3 = zipper2.moveRightBy(<span class="hljs-number">2</span>)
zipper3: zipper.<span class="hljs-type">Zipper</span>[scala.xml.<span class="hljs-type">Node</span>] = <span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;, &lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;),&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;,<span class="hljs-type">List</span>(&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;),<span class="hljs-type">Some</span>(<span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(),&lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;&lt;/tree&gt;,<span class="hljs-type">List</span>(),<span class="hljs-type">None</span>)))

scala&gt; diagram(zipper3).render(<span class="hljs-string">&quot;zipper3&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/zipper3.png" alt="zipper3"></div></p>
<p>This is interesting! Notice that the left siblings are &#x201C;inverted&#x201D;.
This allows to move left and right in constant time, because the sibling
adjacent to the focus is always at the head of the list.</p>
<p>This also allows us to insert new siblings easily:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> zipper4 = zipper3.insertLeft(&lt;fruit/&gt;)
zipper4: zipper.<span class="hljs-type">Zipper</span>[scala.xml.<span class="hljs-type">Node</span>] = <span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(&lt;fruit/&gt;, &lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;, &lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;),&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;,<span class="hljs-type">List</span>(&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;),<span class="hljs-type">Some</span>(<span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(),&lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;&lt;/tree&gt;,<span class="hljs-type">List</span>(),<span class="hljs-type">None</span>)))

scala&gt; diagram(zipper4).render(<span class="hljs-string">&quot;zipper4&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/zipper4.png" alt="zipper4"></div></p>
<p>And, as you might know, we can delete nodes and update the focus:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> zipper5 = zipper4.deleteAndMoveRight.set(&lt;worm/&gt;)
zipper5: zipper.<span class="hljs-type">Zipper</span>[scala.xml.<span class="hljs-type">Node</span>] = <span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(&lt;fruit/&gt;, &lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;, &lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;),&lt;worm/&gt;,<span class="hljs-type">List</span>(),<span class="hljs-type">Some</span>(<span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(),&lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;4&quot;</span>/&gt;&lt;tree value=<span class="hljs-string">&quot;5&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;6&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;7&quot;</span>/&gt;&lt;/tree&gt;&lt;/tree&gt;,<span class="hljs-type">List</span>(),<span class="hljs-type">None</span>)))

scala&gt; diagram(zipper5).render(<span class="hljs-string">&quot;zipper5&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/zipper5.png" alt="zipper5"></div></p>
<p>Finally, when we move up, the siblings at the current level are &#x201C;zipped&#x201D;
together and their parent node is updated:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> zipper6 = zipper5.moveUp
zipper6: zipper.<span class="hljs-type">Zipper</span>[scala.xml.<span class="hljs-type">Node</span>] = <span class="hljs-type">Zipper</span>(<span class="hljs-type">List</span>(),&lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;fruit/&gt;&lt;worm/&gt;&lt;/tree&gt;,<span class="hljs-type">List</span>(),<span class="hljs-type">None</span>)

scala&gt; diagram(zipper6).render(<span class="hljs-string">&quot;zipper6&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/zipper6.png" alt="zipper6"></div></p>
<p>When we are done editing, the <code>.commit</code> shorthand can be used for going
all the way up (applying all the changes) and returning the focus.
Notice how all the unchanged nodes are shared between the old and the new XML.</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> notSoSimpleXml = zipper6.commit
notSoSimpleXml: scala.xml.<span class="hljs-type">Node</span> = &lt;tree value=<span class="hljs-string">&quot;1&quot;</span>&gt;&lt;leaf value=<span class="hljs-string">&quot;2&quot;</span>/&gt;&lt;leaf value=<span class="hljs-string">&quot;3&quot;</span>/&gt;&lt;fruit/&gt;&lt;worm/&gt;&lt;/tree&gt;

scala&gt; (diagram(<span class="hljs-type">Data</span>.simpleXml) + diagram(notSoSimpleXml)).render(<span class="hljs-string">&quot;notSoSimpleXml&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/visualize/zippers/notSoSimpleXml.png" alt="notSoSimpleXml"></div></p>
<p><em>Using an XML zipper, a determined reader can easily implement advanced lenses,
such as <code>Optics.collectFirst</code>, <code>Optics.collectLeftByKey</code>, etc, all found
<a href="https://github.com/stanch/reftree/blob/master/core/shared/src/main/scala/reftree/util/Optics.scala" target="_blank">here</a>.</em></p>
<p>To conclude, here is an animation of a zipper and the tree it operates on
(from my previous talk), produced (as we know now) not without zippers&#x2019; help:</p>
<p><div class="image-wrapper"><img src="../images/tree+zipper.gif" alt="tree+zipper"></div></p>
<p>That&#x2019;s all! Thank you for reading this far.
I hope you are leaving this page with some great <code>reftree</code> use-cases in mind :)</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Immutability.html" class="navigation navigation-prev " aria-label="Previous page: Unzipping immutability">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../JsDemo.html" class="navigation navigation-next " aria-label="Next page: Scala.js demo">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Visualize your data structures!","level":"3.1.2","depth":2,"next":{"title":"Scala.js demo","level":"3.2","depth":1,"path":"JsDemo.md","ref":"JsDemo.md","articles":[]},"previous":{"title":"Unzipping immutability","level":"3.1.1","depth":2,"path":"talks/Immutability.md","ref":"talks/Immutability.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["-fontsettings","github","youtube","image-wrapper","anchorjs"],"pluginsConfig":{"image-wrapper":{},"youtube":{},"github":{"url":"https://github.com/stanch/reftree"},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{"placement":"right","visible":"touch"}},"structure":{"langs":"LANGS.md","readme":"Overview.md","glossary":"GLOSSARY.md","summary":"Navigation.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"talks/Visualize.md","mtime":"2017-06-25T13:35:22.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-07-01T13:52:57.727Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    

    </body>
</html>

