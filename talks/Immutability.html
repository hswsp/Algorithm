
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Unzipping immutability Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400,400i" rel="stylesheet"/>
    <script type="text/javascript" src="//unpkg.com/viz.js"></script>

    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="Visualize.html" />
    
    
    <link rel="prev" href="../Talks.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Documentation</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Overview
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="../">
            
                <a href="../#features">
            
                    
                    Features
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="../">
            
                <a href="../#getting-started">
            
                    
                    Getting started
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../Guide.html">
            
                <a href="../Guide.html">
            
                    
                    Guide
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../Guide.html">
            
                <a href="../Guide.html#trees">
            
                    
                    Trees
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../Guide.html">
            
                <a href="../Guide.html#renderers">
            
                    
                    Renderers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../Guide.html">
            
                <a href="../Guide.html#diagrams">
            
                    
                    Diagrams
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../Guide.html">
            
                <a href="../Guide.html#animations">
            
                    
                    Animations
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <a target="_blank" href="https://stanch.github.io/reftree/api/jvm/index.html">
            
                    
                    Scala API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <a target="_blank" href="https://stanch.github.io/reftree/api/js/index.html">
            
                    
                    Scala.js API
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Useful links</li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <a target="_blank" href="https://github.com/stanch/reftree">
            
                    
                    GitHub page
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" >
            
                <a target="_blank" href="https://gitter.im/stanch/reftree">
            
                    
                    Gitter chat
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Talks & demos</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../Talks.html">
            
                <a href="../Talks.html">
            
                    
                    Talks
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="3.1.1" data-path="Immutability.html">
            
                <a href="Immutability.html">
            
                    
                    Unzipping immutability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="Visualize.html">
            
                <a href="Visualize.html">
            
                    
                    Visualize your data structures!
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../JsDemo.html">
            
                <a href="../JsDemo.html">
            
                    
                    Scala.js demo
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Unzipping immutability</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="unzipping-immutability">Unzipping Immutability</h1>
<p>This page contains the materials for my talk &#x201C;Unzipping Immutability&#x201D;.
Here are some past presentations:</p>
<ul>
<li><a href="http://www.lxscala.com/schedule/#session-2" target="_blank">LX Scala, April 2016</a> (<a href="https://vimeo.com/162214356" target="_blank">video</a>).</li>
<li><a href="https://github.com/PixelsCamp/talks/blob/master/unzipping-immutability_nick-stanchenko.md" target="_blank">Pixels Camp, October 2016</a> (<a href="https://www.youtube.com/watch?v=yeMvhuD689A" target="_blank">video</a>).</li>
<li><a href="http://sched.co/7iTv" target="_blank">Scala By The Bay, November 2016</a> (<a href="https://www.youtube.com/watch?v=dOj-wk5MQ3k" target="_blank">video</a>).</li>
</ul>
<p><div style="position: relative;padding-bottom: 56.25%;padding-top: 25px;height: 0;"><iframe frameborder="0" allowfullscreen style="border: none;position: absolute;top: 0;left: 0;width: 100%;height: 100%;" src="//www.youtube.com/embed/dOj-wk5MQ3k"></iframe></div></p>
<p>You can use this page in two ways:</p>
<ul>
<li>as a reference/refresher on the concepts covered in the talk;</li>
<li>as an interactive playground where you can try the same commands I presented.</li>
</ul>
<p>Here is an overview:</p>
<ul>
<li><a href="#immutable-data-structures">Immutable data structures</a></li>
<li><a href="#lenses">Lenses</a></li>
<li><a href="#zippers">Zippers</a></li>
<li><a href="#useful-resources">Useful resources</a></li>
</ul>
<p>Throughout this page we will assume the following
declarations (each section might add its own):</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> reftree.core._
<span class="hljs-keyword">import</span> reftree.diagram._
<span class="hljs-keyword">import</span> reftree.render._
<span class="hljs-keyword">import</span> reftree.demo.<span class="hljs-type">Data</span>._
<span class="hljs-keyword">import</span> scala.collection.immutable._
<span class="hljs-keyword">import</span> java.nio.file.<span class="hljs-type">Paths</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">Diagram</span>.{sourceCodeCaption &#x21D2; diagram}
</code></pre>
<p>To start an interactive session, just run</p>
<pre><code>$ sbt demo
@ render(List(1, 2, 3))
</code></pre><p>and open <code>diagram.png</code> in your favorite image viewer (hopefully one that
reloads images automatically on file change). You will also need to have
<a href="http://www.graphviz.org/" target="_blank">GraphViz</a> installed. <em>The interactive session
already has all the necessary imports in scope.</em></p>
<h2 id="immutable-data-structures">Immutable data structures</h2>
<pre><code class="lang-scala"><span class="hljs-comment">// extra declarations for this section</span>
<span class="hljs-keyword">val</span> renderer = <span class="hljs-type">Renderer</span>(
  renderingOptions = <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">100</span>),
  directory = <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;immutability&quot;</span>, <span class="hljs-string">&quot;data&quot;</span>)
)
<span class="hljs-keyword">import</span> renderer._
</code></pre>
<h3 id="lists">Lists</h3>
<p>We&#x2019;ll start with one of the simplest structures: a list.
It consists of a number of cells pointing to each other:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> list = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
list: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
</code></pre>
<pre><code class="lang-scala">diagram(list).render(<span class="hljs-string">&quot;list&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/data/list.png" alt="list"></div></p>
<p>Elements can be added to or removed from the front of the list with no effort,
because we can share the same cells across several lists.
This would not be possible with a mutable list,
since modifying the shared part would modify every data structure making use of it.</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> add = <span class="hljs-number">0</span> :: list
add: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

scala&gt; <span class="hljs-keyword">val</span> remove = list.tail
remove: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">List</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
</code></pre>
<pre><code class="lang-scala">(diagram(list) + diagram(add) + diagram(remove)).render(<span class="hljs-string">&quot;lists&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/data/lists.png" alt="lists"></div></p>
<p>However we can&#x2019;t easily add elements at the end of the list, since the last cell
is pointing to the empty list (<code>Nil</code>) and is immutable, i.e. cannot be changed.
Thus we are forced to create a new list every time:</p>
<pre><code class="lang-scala">(<span class="hljs-type">Animation</span>
  .startWith(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>))
  .iterate(_ :+ <span class="hljs-number">2</span>, _ :+ <span class="hljs-number">3</span>, _ :+ <span class="hljs-number">4</span>)
  .build()
  .render(<span class="hljs-string">&quot;list-append&quot;</span>, tweakAnimation = _.withOnionSkinLayers(<span class="hljs-number">3</span>)))
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/data/list-append.gif" alt="list-append"></div></p>
<p>This certainly does not look efficient compared to adding elements at the front:</p>
<pre><code class="lang-scala">(<span class="hljs-type">Animation</span>
  .startWith(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>))
  .iterate(<span class="hljs-number">2</span> :: _, <span class="hljs-number">3</span> :: _, <span class="hljs-number">4</span> :: _)
  .build()
  .render(<span class="hljs-string">&quot;list-prepend&quot;</span>))
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/data/list-prepend.gif" alt="list-prepend"></div></p>
<h3 id="queues">Queues</h3>
<p>If we want to add elements on both sides efficiently, we need a different data structure: a queue.
The queue below, also known as a &#x201C;Banker&#x2019;s Queue&#x201D;, has two lists: one for prepending and one for appending.</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> queue1 = <span class="hljs-type">Queue</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
queue1: scala.collection.immutable.<span class="hljs-type">Queue</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Queue</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

scala&gt; <span class="hljs-keyword">val</span> queue2 = (queue1 :+ <span class="hljs-number">4</span>).tail
queue2: scala.collection.immutable.<span class="hljs-type">Queue</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Queue</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
</code></pre>
<pre><code class="lang-scala">(diagram(queue1) + diagram(queue2)).render(<span class="hljs-string">&quot;queues&quot;</span>, _.withVerticalSpacing(<span class="hljs-number">1.2</span>))
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/data/queues.png" alt="queues"></div></p>
<p>This way we can add and remove elements very easily at both ends.
Except when we try to remove an element and the respective list is empty!
In this case the queue will rotate the other list to make use of its elements.
Although this operation is expensive, the usage pattern intended for a queue
makes it rare enough to yield great average (&#x201C;ammortized&#x201D;) performance:</p>
<pre><code class="lang-scala">(<span class="hljs-type">Animation</span>
  .startWith(<span class="hljs-type">Queue</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))
  .repeat(<span class="hljs-number">3</span>)(_.iterate(<span class="hljs-number">2</span>)(q &#x21D2; q :+ (q.max + <span class="hljs-number">1</span>)).iterate(<span class="hljs-number">2</span>)(_.tail))
  .build(<span class="hljs-type">Diagram</span>.toStringCaption(_).withAnchor(<span class="hljs-string">&quot;queue&quot;</span>))
  .render(<span class="hljs-string">&quot;queue&quot;</span>))
</code></pre>
<p><div class="image-wrapper"><img src="../images/queue.gif" alt="queue"></div></p>
<h3 id="vectors">Vectors</h3>
<p>One downside common to both lists and queues we saw before is that to get an element by index,
we need to potentially traverse the whole structure. A <code>Vector</code> is a powerful data structure
addressing this shortcoming and available in Scala (among other languages, like Clojure).</p>
<p>Internally vectors utilize up to 6 layers of arrays, where 32 elements sit on the first layer,
1024 &#x2014; on the second, 32^3 &#x2014; on the third, etc.
Therefore getting any element by its index requires at most 6 pointer dereferences,
which can be deemed constant time (yes, the trick is that the number of elements that can
be stored is limited by 2^31).</p>
<p>The internal 32-element arrays form the basic structural sharing blocks.
For small vectors they will be recreated on most operations:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> vector1 = (<span class="hljs-number">1</span> to <span class="hljs-number">20</span>).toVector
vector1: <span class="hljs-type">Vector</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>)

scala&gt; <span class="hljs-keyword">val</span> vector2 = vector1 :+ <span class="hljs-number">21</span>
vector2: scala.collection.immutable.<span class="hljs-type">Vector</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>)
</code></pre>
<pre><code class="lang-scala">(diagram(vector1) + diagram(vector2)).render(<span class="hljs-string">&quot;vectors&quot;</span>, _.withVerticalSpacing(<span class="hljs-number">2</span>))
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/data/vectors.png" alt="vectors"></div></p>
<p>However as more layers leap into action, a huge chunk of the data can be shared:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> vector1 = (<span class="hljs-number">1</span> to <span class="hljs-number">100</span>).toVector
vector1: <span class="hljs-type">Vector</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>, <span class="hljs-number">35</span>, <span class="hljs-number">36</span>, <span class="hljs-number">37</span>, <span class="hljs-number">38</span>, <span class="hljs-number">39</span>, <span class="hljs-number">40</span>, <span class="hljs-number">41</span>, <span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">46</span>, <span class="hljs-number">47</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">53</span>, <span class="hljs-number">54</span>, <span class="hljs-number">55</span>, <span class="hljs-number">56</span>, <span class="hljs-number">57</span>, <span class="hljs-number">58</span>, <span class="hljs-number">59</span>, <span class="hljs-number">60</span>, <span class="hljs-number">61</span>, <span class="hljs-number">62</span>, <span class="hljs-number">63</span>, <span class="hljs-number">64</span>, <span class="hljs-number">65</span>, <span class="hljs-number">66</span>, <span class="hljs-number">67</span>, <span class="hljs-number">68</span>, <span class="hljs-number">69</span>, <span class="hljs-number">70</span>, <span class="hljs-number">71</span>, <span class="hljs-number">72</span>, <span class="hljs-number">73</span>, <span class="hljs-number">74</span>, <span class="hljs-number">75</span>, <span class="hljs-number">76</span>, <span class="hljs-number">77</span>, <span class="hljs-number">78</span>, <span class="hljs-number">79</span>, <span class="hljs-number">80</span>, <span class="hljs-number">81</span>, <span class="hljs-number">82</span>, <span class="hljs-number">83</span>, <span class="hljs-number">84</span>, <span class="hljs-number">85</span>, <span class="hljs-number">86</span>, <span class="hljs-number">87</span>, <span class="hljs-number">88</span>, <span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">91</span>, <span class="hljs-number">92</span>, <span class="hljs-number">93</span>, <span class="hljs-number">94</span>, <span class="hljs-number">95</span>, <span class="hljs-number">96</span>, <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>)

scala&gt; <span class="hljs-keyword">val</span> vector2 = vector1 :+ <span class="hljs-number">21</span>
vector2: scala.collection.immutable.<span class="hljs-type">Vector</span>[<span class="hljs-type">Int</span>] = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>, <span class="hljs-number">35</span>, <span class="hljs-number">36</span>, <span class="hljs-number">37</span>, <span class="hljs-number">38</span>, <span class="hljs-number">39</span>, <span class="hljs-number">40</span>, <span class="hljs-number">41</span>, <span class="hljs-number">42</span>, <span class="hljs-number">43</span>, <span class="hljs-number">44</span>, <span class="hljs-number">45</span>, <span class="hljs-number">46</span>, <span class="hljs-number">47</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">50</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">53</span>, <span class="hljs-number">54</span>, <span class="hljs-number">55</span>, <span class="hljs-number">56</span>, <span class="hljs-number">57</span>, <span class="hljs-number">58</span>, <span class="hljs-number">59</span>, <span class="hljs-number">60</span>, <span class="hljs-number">61</span>, <span class="hljs-number">62</span>, <span class="hljs-number">63</span>, <span class="hljs-number">64</span>, <span class="hljs-number">65</span>, <span class="hljs-number">66</span>, <span class="hljs-number">67</span>, <span class="hljs-number">68</span>, <span class="hljs-number">69</span>, <span class="hljs-number">70</span>, <span class="hljs-number">71</span>, <span class="hljs-number">72</span>, <span class="hljs-number">73</span>, <span class="hljs-number">74</span>, <span class="hljs-number">75</span>, <span class="hljs-number">76</span>, <span class="hljs-number">77</span>, <span class="hljs-number">78</span>, <span class="hljs-number">79</span>, <span class="hljs-number">80</span>, <span class="hljs-number">81</span>, <span class="hljs-number">82</span>, <span class="hljs-number">83</span>, <span class="hljs-number">84</span>, <span class="hljs-number">85</span>, <span class="hljs-number">86</span>, <span class="hljs-number">87</span>, <span class="hljs-number">88</span>, <span class="hljs-number">89</span>, <span class="hljs-number">90</span>, <span class="hljs-number">91</span>, <span class="hljs-number">92</span>, <span class="hljs-number">93</span>, <span class="hljs-number">94</span>, <span class="hljs-number">95</span>, <span class="hljs-number">96</span>, <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">100</span>, <span class="hljs-number">21</span>)
</code></pre>
<pre><code class="lang-scala">(diagram(vector1) + diagram(vector2)).render(<span class="hljs-string">&quot;big-vectors&quot;</span>, _.withVerticalSpacing(<span class="hljs-number">2</span>))
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/data/big-vectors.png" alt="big-vectors"></div></p>
<p>If you want to know more, this structure is covered in great detail by Jean Niklas L&#x2019;orange
<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" target="_blank">in his blog</a>.
I also highly recommend watching <a href="https://www.youtube.com/watch?v=pNhBQJN44YQ" target="_blank">this talk</a> by Daniel Spiewak.</p>
<h3 id="finger-trees">Finger Trees</h3>
<p>To conclude this section, I would like to share a slightly less popular, but beautifully designed
data structure called &#x201C;finger tree&#x201D; described in <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf" target="_blank">this paper</a>
by Hinze and Paterson. Enjoy the read and this animation of a finger tree getting filled with some numbers:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> de.sciss.fingertree.{<span class="hljs-type">FingerTree</span>, <span class="hljs-type">Measure</span>}
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">FingerTreeInstances</span>._

<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> measure = <span class="hljs-type">Measure</span>.<span class="hljs-type">Indexed</span>

<span class="hljs-type">Animation</span>
  .startWith(<span class="hljs-type">FingerTree</span>(<span class="hljs-number">1</span>))
  .iterateWithIndex(<span class="hljs-number">21</span>)((t, i) &#x21D2; t :+ (i + <span class="hljs-number">1</span>))
  .build(<span class="hljs-type">Diagram</span>(_).withCaption(<span class="hljs-string">&quot;Finger Tree&quot;</span>).withAnchor(<span class="hljs-string">&quot;tree&quot;</span>))
  .render(<span class="hljs-string">&quot;finger&quot;</span>, _.withDensity(<span class="hljs-number">75</span>).withVerticalSpacing(<span class="hljs-number">2</span>))
</code></pre>
<p><div class="image-wrapper"><img src="../images/finger.gif" alt="finger"></div></p>
<h2 id="lenses">Lenses</h2>
<p>So far we were looking into &#x201C;standard&#x201D; data structures,
but in our code we often have to deal with custom data structures comprising our domain model.
Updating this sort of data can be tricky if it&#x2019;s immutable.
For case classes Scala gives us the <code>copy</code> method:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">
  name: <span class="hljs-type">String</span>,
  salary: <span class="hljs-type">Long</span>
</span>)</span>
</code></pre>
<pre><code class="lang-scala">scala&gt; employee
res8: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Employee</span> = <span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4000</span>)

scala&gt; <span class="hljs-keyword">val</span> raisedEmployee = employee.copy(salary = employee.salary + <span class="hljs-number">10</span>)
raisedEmployee: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Employee</span> = <span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4010</span>)
</code></pre>
<p>However once composition comes into play, the resulting nested immutable data structures
would require a lot of <code>copy</code> calls:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">
  name: <span class="hljs-type">String</span>,
  salary: <span class="hljs-type">Long</span>
</span>)</span>

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Startup</span>(<span class="hljs-params">
  name: <span class="hljs-type">String</span>,
  founder: <span class="hljs-type">Employee</span>,
  team: <span class="hljs-type">List</span>[<span class="hljs-type">Employee</span>]
</span>)</span>
</code></pre>
<pre><code class="lang-scala">scala&gt; startup
res9: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span> = <span class="hljs-type">Startup</span>(<span class="hljs-type">Acme</span>,<span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4000</span>),<span class="hljs-type">List</span>(<span class="hljs-type">Employee</span>(<span class="hljs-type">Adam</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Bella</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Chad</span>,<span class="hljs-number">1980</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Delia</span>,<span class="hljs-number">1850</span>)))

scala&gt; <span class="hljs-keyword">val</span> raisedFounder = startup.copy(
     |   founder = startup.founder.copy(
     |     salary = startup.founder.salary + <span class="hljs-number">10</span>
     |   )
     | )
raisedFounder: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span> = <span class="hljs-type">Startup</span>(<span class="hljs-type">Acme</span>,<span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4010</span>),<span class="hljs-type">List</span>(<span class="hljs-type">Employee</span>(<span class="hljs-type">Adam</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Bella</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Chad</span>,<span class="hljs-number">1980</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Delia</span>,<span class="hljs-number">1850</span>)))
</code></pre>
<pre><code class="lang-scala"><span class="hljs-comment">// extra declarations for this section</span>
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">SimplifiedInstances</span>.list
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">OpticInstances</span>._

<span class="hljs-keyword">val</span> renderer = <span class="hljs-type">Renderer</span>(
  renderingOptions = <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">75</span>),
  directory = <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;immutability&quot;</span>, <span class="hljs-string">&quot;lenses&quot;</span>)
)
<span class="hljs-keyword">import</span> renderer._
</code></pre>
<pre><code class="lang-scala">(diagram(startup) + diagram(raisedFounder)).render(<span class="hljs-string">&quot;startup&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/lenses/startup.png" alt="startup"></div></p>
<p>Ouch!</p>
<p>A common solution to this problem is a &#x201C;lens&#x201D;.
In the simplest case a lens is a pair of functions to get and set a value of type <code>B</code> inside a value of type <code>A</code>.
It&#x2019;s called a lens because it focuses on some part of the data and allows to update it.
For example, here is a lens that focuses on an employee&#x2019;s salary
(using the excellent <a href="https://github.com/julien-truffaut/Monocle" target="_blank">Monocle library</a>):</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">GenLens</span>
<span class="hljs-keyword">import</span> monocle.macros.<span class="hljs-type">GenLens</span>

scala&gt; <span class="hljs-keyword">val</span> salaryLens = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Employee</span>](_.salary)
salaryLens: monocle.<span class="hljs-type">Lens</span>[reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Employee</span>,<span class="hljs-type">Long</span>] = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">4</span>bfef05a

scala&gt; salaryLens.get(startup.founder)
res13: <span class="hljs-type">Long</span> = <span class="hljs-number">4000</span>

scala&gt; salaryLens.modify(s =&gt; s + <span class="hljs-number">10</span>)(startup.founder)
res14: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Employee</span> = <span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4010</span>)
</code></pre>
<pre><code class="lang-scala">diagram(<span class="hljs-type">OpticFocus</span>(salaryLens, startup.founder)).render(<span class="hljs-string">&quot;salaryLens&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/lenses/salaryLens.png" alt="salaryLens"></div></p>
<p>We can also define a lens that focuses on the startup&#x2019;s founder:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> founderLens = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Startup</span>](_.founder)
founderLens: monocle.<span class="hljs-type">Lens</span>[reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span>,reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Employee</span>] = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">44</span>f414f0

scala&gt; founderLens.get(startup)
res16: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Employee</span> = <span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4000</span>)
</code></pre>
<pre><code class="lang-scala">diagram(<span class="hljs-type">OpticFocus</span>(founderLens, startup)).render(<span class="hljs-string">&quot;founderLens&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/lenses/founderLens.png" alt="founderLens"></div></p>
<p>It&#x2019;s not apparent yet how this would help, but the trick is that lenses can be composed:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> founderSalaryLens = founderLens composeLens salaryLens
founderSalaryLens: monocle.<span class="hljs-type">PLens</span>[reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span>,reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span>,<span class="hljs-type">Long</span>,<span class="hljs-type">Long</span>] = monocle.<span class="hljs-type">PLens</span>$$anon$<span class="hljs-number">1</span>@<span class="hljs-number">46</span>b9b8ee

scala&gt; founderSalaryLens.get(startup)
res18: <span class="hljs-type">Long</span> = <span class="hljs-number">4000</span>

scala&gt; founderSalaryLens.modify(s =&gt; s + <span class="hljs-number">10</span>)(startup)
res19: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span> = <span class="hljs-type">Startup</span>(<span class="hljs-type">Acme</span>,<span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4010</span>),<span class="hljs-type">List</span>(<span class="hljs-type">Employee</span>(<span class="hljs-type">Adam</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Bella</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Chad</span>,<span class="hljs-number">1980</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Delia</span>,<span class="hljs-number">1850</span>)))
</code></pre>
<pre><code class="lang-scala">diagram(<span class="hljs-type">OpticFocus</span>(founderSalaryLens, startup)).render(<span class="hljs-string">&quot;founderSalaryLens&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/lenses/founderSalaryLens.png" alt="founderSalaryLens"></div></p>
<p>One interesting thing is that lenses can focus on anything, not just direct attributes of the data.
Here is a traversal &#x2014; a more generic kind of lens &#x2014; that focuses on all vowels in a string:</p>
<pre><code class="lang-scala">diagram(<span class="hljs-type">OpticFocus</span>(vowelTraversal, <span class="hljs-string">&quot;example&quot;</span>)).render(<span class="hljs-string">&quot;vowelTraversal&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/lenses/vowelTraversal.png" alt="vowelTraversal"></div></p>
<p>We can use it to give our founder a funny name:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> employeeNameLens = <span class="hljs-type">GenLens</span>[<span class="hljs-type">Employee</span>](_.name)
employeeNameLens: monocle.<span class="hljs-type">Lens</span>[reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Employee</span>,<span class="hljs-type">String</span>] = $anon$<span class="hljs-number">1</span>@<span class="hljs-number">673</span>ec069

scala&gt; <span class="hljs-keyword">val</span> founderVowelTraversal = founderLens composeLens employeeNameLens composeTraversal vowelTraversal
founderVowelTraversal: monocle.<span class="hljs-type">PTraversal</span>[reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span>,reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span>,<span class="hljs-type">Char</span>,<span class="hljs-type">Char</span>] = monocle.<span class="hljs-type">PTraversal</span>$$anon$<span class="hljs-number">2</span>@<span class="hljs-number">2784</span>a907

scala&gt; founderVowelTraversal.modify(v =&gt; v.toUpper)(startup)
res22: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span> = <span class="hljs-type">Startup</span>(<span class="hljs-type">Acme</span>,<span class="hljs-type">Employee</span>(<span class="hljs-type">MIchAEl</span>,<span class="hljs-number">4000</span>),<span class="hljs-type">List</span>(<span class="hljs-type">Employee</span>(<span class="hljs-type">Adam</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Bella</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Chad</span>,<span class="hljs-number">1980</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Delia</span>,<span class="hljs-number">1850</span>)))
</code></pre>
<pre><code class="lang-scala">diagram(<span class="hljs-type">OpticFocus</span>(founderVowelTraversal, startup)).render(<span class="hljs-string">&quot;founderVowelTraversal&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/lenses/founderVowelTraversal.png" alt="founderVowelTraversal"></div></p>
<p>So far we have replaced the <code>copy</code> boilerplate with a number of lens declarations.
However most of the time our goal is just to update data.</p>
<p>In Scala there is a great library called <a href="https://github.com/adamw/quicklens" target="_blank">quicklens</a>
that allows to do exactly that, creating all the necessary lenses under the hood:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">import</span> com.softwaremill.quicklens._
<span class="hljs-keyword">import</span> com.softwaremill.quicklens._

scala&gt; <span class="hljs-keyword">val</span> raisedCeo = startup.modify(_.founder.salary).using(s =&gt; s + <span class="hljs-number">10</span>)
raisedCeo: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span> = <span class="hljs-type">Startup</span>(<span class="hljs-type">Acme</span>,<span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4010</span>),<span class="hljs-type">List</span>(<span class="hljs-type">Employee</span>(<span class="hljs-type">Adam</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Bella</span>,<span class="hljs-number">2100</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Chad</span>,<span class="hljs-number">1980</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Delia</span>,<span class="hljs-number">1850</span>)))
</code></pre>
<p>You might think this is approaching the syntax for updating mutable data,
but actually we have already surpassed it, since lenses are much more flexible:</p>
<pre><code class="lang-scala">scala&gt; <span class="hljs-keyword">val</span> raisedEveryone = startup.modifyAll(_.founder.salary, _.team.each.salary).using(s =&gt; s + <span class="hljs-number">10</span>)
raisedEveryone: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Startup</span> = <span class="hljs-type">Startup</span>(<span class="hljs-type">Acme</span>,<span class="hljs-type">Employee</span>(<span class="hljs-type">Michael</span>,<span class="hljs-number">4010</span>),<span class="hljs-type">List</span>(<span class="hljs-type">Employee</span>(<span class="hljs-type">Adam</span>,<span class="hljs-number">2110</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Bella</span>,<span class="hljs-number">2110</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Chad</span>,<span class="hljs-number">1990</span>), <span class="hljs-type">Employee</span>(<span class="hljs-type">Delia</span>,<span class="hljs-number">1860</span>)))
</code></pre>
<h2 id="zippers">Zippers</h2>
<p>In our domain models we are often faced with recursive data structures.
Consider this example:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">
  name: <span class="hljs-type">String</span>,
  salary: <span class="hljs-type">Long</span>
</span>)</span>

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hierarchy</span>(<span class="hljs-params">
  employee: <span class="hljs-type">Employee</span>,
  team: <span class="hljs-type">List</span>[<span class="hljs-type">Hierarchy</span>]
</span>)</span>

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Company</span>(<span class="hljs-params">
  name: <span class="hljs-type">String</span>,
  hierarchy: <span class="hljs-type">Hierarchy</span>
</span>)</span>
</code></pre>
<p>The <code>Hierarchy</code> class refers to itself.
Let&#x2019;s grab a company object and display its hierarchy as a tree:</p>
<pre><code class="lang-scala"><span class="hljs-comment">// extra declarations for this section</span>
<span class="hljs-keyword">import</span> zipper._
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">SimplifiedInstances</span>.option
<span class="hljs-keyword">import</span> reftree.contrib.<span class="hljs-type">ZipperInstances</span>._

<span class="hljs-keyword">val</span> renderer = <span class="hljs-type">Renderer</span>(
  renderingOptions = <span class="hljs-type">RenderingOptions</span>(density = <span class="hljs-number">100</span>),
  directory = <span class="hljs-type">Paths</span>.get(<span class="hljs-type">ImagePath</span>, <span class="hljs-string">&quot;immutability&quot;</span>, <span class="hljs-string">&quot;zippers&quot;</span>)
)
<span class="hljs-keyword">import</span> renderer._
</code></pre>
<pre><code class="lang-scala">diagram(company.hierarchy).render(<span class="hljs-string">&quot;company&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/company.png" alt="company"></div></p>
<p>What if we want to navigate through this tree and modify it along the way?
We can use <a href="#lenses">lenses</a>, but the recursive nature of the tree allows for a better solution.</p>
<p>This solution is called a &#x201C;Zipper&#x201D;, and was introduced by G&#xE9;rard Huet in 1997.
It consists of a &#x201C;cursor&#x201D; pointing to a location anywhere in the tree &#x2014; &#x201C;current focus&#x201D;.
The cursor can be moved freely with operations like <code>moveDownLeft</code>, <code>moveRight</code>, <code>moveUp</code>, etc.
Current focus can be updated, deleted, or new nodes can be inserted to its left or right.
Zippers are immutable, and every operation returns a new Zipper.
All the changes made to the tree can be committed, yielding a new modified version of the original tree.</p>
<p>Here is how we would insert a new employee into the hierarchy:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> updatedHierarchy = <span class="hljs-type">Zipper</span>(company.hierarchy).moveDownRight.moveDownRight.insertRight(newHire).commit
</code></pre>
<pre><code class="lang-scala">(diagram(company.hierarchy) + diagram(updatedHierarchy)).render(<span class="hljs-string">&quot;updatedHierarchy&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/updatedHierarchy.png" alt="updatedHierarchy"></div></p>
<p>My <a href="https://github.com/stanch/zipper#zipper--an-implementation-of-huets-zipper" target="_blank">zipper library</a>
provides a few useful movements and operations.</p>
<p>Let&#x2019;s consider a simpler recursive data structure:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span>(<span class="hljs-params">x: <span class="hljs-type">Int</span>, c: <span class="hljs-type">List</span>[<span class="hljs-type">Tree</span>] = <span class="hljs-type">List</span>.empty</span>)</span>
</code></pre>
<p>and a simple tree:</p>
<pre><code class="lang-scala">scala&gt; simpleTree
res28: reftree.demo.<span class="hljs-type">Data</span>.<span class="hljs-type">Tree</span> = <span class="hljs-type">Tree</span>(<span class="hljs-number">1</span>,<span class="hljs-type">List</span>(<span class="hljs-type">Tree</span>(<span class="hljs-number">2</span>,<span class="hljs-type">List</span>()), <span class="hljs-type">Tree</span>(<span class="hljs-number">3</span>,<span class="hljs-type">List</span>()), <span class="hljs-type">Tree</span>(<span class="hljs-number">4</span>,<span class="hljs-type">List</span>()), <span class="hljs-type">Tree</span>(<span class="hljs-number">5</span>,<span class="hljs-type">List</span>(<span class="hljs-type">Tree</span>(<span class="hljs-number">6</span>,<span class="hljs-type">List</span>()), <span class="hljs-type">Tree</span>(<span class="hljs-number">7</span>,<span class="hljs-type">List</span>())))))
</code></pre>
<pre><code class="lang-scala">diagram(simpleTree).render(<span class="hljs-string">&quot;simpleTree&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/simpleTree.png" alt="simpleTree"></div></p>
<p>When we wrap a Zipper around this tree, it does not look very interesting yet:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> zipper1 = <span class="hljs-type">Zipper</span>(simpleTree)
</code></pre>
<pre><code class="lang-scala">(diagram(simpleTree) + diagram(zipper1)).render(<span class="hljs-string">&quot;zipper1&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper1.png" alt="zipper1"></div></p>
<p>We can see that it just points to the original tree and has some other empty fields.
More specifically, a Zipper consists of four pointers:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zipper</span>[<span class="hljs-type">A</span>](<span class="hljs-params">
  left: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>],           // left siblings of the focus
  focus: <span class="hljs-type">A</span>,                // the current focus
  right: <span class="hljs-type">List</span>[<span class="hljs-type">A</span>],          // right siblings of the focus
  top: <span class="hljs-type">Option</span>[<span class="hljs-type">Zipper</span>[<span class="hljs-type">A</span>]]   // the parent zipper
</span>)</span>
</code></pre>
<p>In this case the focus is the root of the tree, which has no siblings,
and the parent zipper does not exist, since we are at the top level.</p>
<p>One thing we can do right away is modify the focus:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> zipper2 = zipper1.update(focus &#x21D2; focus.copy(x = focus.x + <span class="hljs-number">99</span>))
</code></pre>
<pre><code class="lang-scala">(diagram(simpleTree) + diagram(zipper1) + diagram(zipper2)).render(<span class="hljs-string">&quot;zipper2&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper2.png" alt="zipper2"></div></p>
<p>We just created a new tree! To obtain it, we have to commit the changes:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> tree2 = zipper2.commit
</code></pre>
<pre><code class="lang-scala">(diagram(simpleTree) + diagram(tree2)).render(<span class="hljs-string">&quot;tree2&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/tree2.png" alt="tree2"></div></p>
<p>If you were following closely,
you would notice that nothing spectacular happened yet:
we could&#x2019;ve easily obtained the same result by modifying the tree directly:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> tree2b = simpleTree.copy(x = simpleTree.x + <span class="hljs-number">99</span>)

assert(tree2b == tree2)
</code></pre>
<p>The power of Zipper becomes apparent when we go one or more levels deep.
To move down the tree, we &#x201C;unzip&#x201D; it, separating the child nodes into
the focused node and its left and right siblings:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> zipper2 = zipper1.moveDownLeft
</code></pre>
<pre><code class="lang-scala">(diagram(zipper1) + diagram(zipper2)).render(<span class="hljs-string">&quot;zipper1+2&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper1+2.png" alt="zipper1+2"></div></p>
<p>The new Zipper links to the old one,
which will allow us to return to the root of the tree when we are done applying changes.
This link however prevents us from seeing the picture clearly.
Let&#x2019;s look at the second zipper alone:</p>
<pre><code class="lang-scala">diagram(zipper2).render(<span class="hljs-string">&quot;zipper2b&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper2b.png" alt="zipper2b"></div></p>
<p>Great! We have <code>2</code> in focus and <code>3, 4, 5</code> as right siblings. What happens if we move right a bit?</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> zipper3 = zipper2.moveRightBy(<span class="hljs-number">2</span>)
</code></pre>
<pre><code class="lang-scala">diagram(zipper3).render(<span class="hljs-string">&quot;zipper3&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper3.png" alt="zipper3"></div></p>
<p>This is interesting! Notice that the left siblings are &#x201C;inverted&#x201D;.
This allows to move left and right in constant time, because the sibling
adjacent to the focus is always at the head of the list.</p>
<p>This also allows us to insert new siblings easily:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> zipper4 = zipper3.insertLeft(<span class="hljs-type">Tree</span>(<span class="hljs-number">34</span>))
</code></pre>
<pre><code class="lang-scala">diagram(zipper4).render(<span class="hljs-string">&quot;zipper4&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper4.png" alt="zipper4"></div></p>
<p>And, as you might know, we can delete nodes and update the focus:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> zipper5 = zipper4.deleteAndMoveRight.set(<span class="hljs-type">Tree</span>(<span class="hljs-number">45</span>))
</code></pre>
<pre><code class="lang-scala">diagram(zipper5).render(<span class="hljs-string">&quot;zipper5&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper5.png" alt="zipper5"></div></p>
<p>Finally, when we move up, the siblings at the current level are &#x201C;zipped&#x201D;
together and their parent node is updated:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> zipper6 = zipper5.moveUp
</code></pre>
<pre><code class="lang-scala">diagram(zipper6).render(<span class="hljs-string">&quot;zipper6&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/immutability/zippers/zipper6.png" alt="zipper6"></div></p>
<p>You can probably guess by now that <code>.commit</code> is a shorthand for going
all the way up (applying all the changes) and returning the focus:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> tree3a = zipper5.moveUp.focus
<span class="hljs-keyword">val</span> tree3b = zipper5.commit

assert(tree3a == tree3b)
</code></pre>
<p>Here is an animation of the navigation process:</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> movement = <span class="hljs-type">Animation</span>
  .startWith(<span class="hljs-type">Zipper</span>(<span class="hljs-type">Data</span>.simpleTree))
  .iterate(
    _.moveDownLeft,
    _.moveRight, _.moveRight, _.moveRight,
    _.moveDownLeft,
    _.moveRight, _.moveLeft,
    _.top.get,
    _.moveLeft, _.moveLeft, _.moveLeft,
    _.top.get
  )

<span class="hljs-keyword">val</span> trees = movement
  .build(z &#x21D2; <span class="hljs-type">Diagram</span>(<span class="hljs-type">ZipperFocus</span>(z, <span class="hljs-type">Data</span>.simpleTree)).withCaption(<span class="hljs-string">&quot;Tree&quot;</span>).withAnchor(<span class="hljs-string">&quot;tree&quot;</span>))
  .toNamespace(<span class="hljs-string">&quot;tree&quot;</span>)

<span class="hljs-keyword">val</span> zippers = movement
  .build(<span class="hljs-type">Diagram</span>(_).withCaption(<span class="hljs-string">&quot;Zipper&quot;</span>).withAnchor(<span class="hljs-string">&quot;zipper&quot;</span>).withColor(<span class="hljs-number">2</span>))
  .toNamespace(<span class="hljs-string">&quot;zipper&quot;</span>)

(trees + zippers).render(<span class="hljs-string">&quot;tree+zipper&quot;</span>)
</code></pre>
<p><div class="image-wrapper"><img src="../images/tree+zipper.gif" alt="tree+zipper"></div></p>
<h2 id="useful-resources">Useful resources</h2>
<h3 id="books-papers-and-talks">Books, papers and talks</h3>
<ul>
<li><a href="http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504" target="_blank">Purely functional data structures</a> by Chris Okasaki,
and/or <a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf" target="_blank">his PhD thesis</a> &#x2014; <em>the</em> introduction to immutable data structures</li>
<li><a href="http://cstheory.stackexchange.com/a/1550" target="_blank">What&#x2019;s new in purely functional data structures since Okasaki</a> &#x2014; an excellent StackExchange answer
with pointers for further reading</li>
<li><a href="https://www.youtube.com/watch?v=pNhBQJN44YQ" target="_blank">Extreme cleverness</a> by Daniel Spiewak &#x2014; a superb talk
covering several immutable data structures (implemented <a href="https://github.com/djspiewak/extreme-cleverness" target="_blank">here</a>)</li>
<li><a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1" target="_blank">Understanding Clojure&#x2019;s Persistent Vectors, part 1</a>
and <a href="http://hypirion.com/musings/understanding-persistent-vector-pt-2" target="_blank">part 2</a> &#x2014; a series of blog posts by Jean Niklas L&#x2019;orange</li>
<li><a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf" target="_blank">Finger Trees</a> and
<a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/Brother12.pdf" target="_blank">1-2 Brother Trees</a> described by Hinze and Paterson</li>
<li><a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf" target="_blank">Huet&#x2019;s original Zipper paper</a> &#x2014; a great short read
introducing the Zipper</li>
<li><a href="http://dspace.library.uu.nl/bitstream/handle/1874/2532/2001-33.pdf" target="_blank">Weaving a web</a> by Hinze and Jeuring &#x2014;
another interesting Zipper-like approach</li>
</ul>
<h3 id="scala-libraries">Scala libraries</h3>
<ul>
<li><a href="https://github.com/stanch/zipper" target="_blank">zipper</a> &#x2014; my Zipper implementation</li>
<li><a href="https://github.com/julien-truffaut/Monocle" target="_blank">Monocle</a> &#x2014; an &#x201C;optics&#x201D; library</li>
<li><a href="https://github.com/adamw/quicklens" target="_blank">Quicklens</a> &#x2014; a simpler way to update nested case classes</li>
<li><a href="https://github.com/Sciss/FingerTree" target="_blank">FingerTree</a> &#x2014; an implementation of the Finger Tree data structure</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../Talks.html" class="navigation navigation-prev " aria-label="Previous page: Talks">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="Visualize.html" class="navigation navigation-next " aria-label="Next page: Visualize your data structures!">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Unzipping immutability","level":"3.1.1","depth":2,"next":{"title":"Visualize your data structures!","level":"3.1.2","depth":2,"path":"talks/Visualize.md","ref":"talks/Visualize.md","articles":[]},"previous":{"title":"Talks","level":"3.1","depth":1,"path":"Talks.md","ref":"Talks.md","articles":[{"title":"Unzipping immutability","level":"3.1.1","depth":2,"path":"talks/Immutability.md","ref":"talks/Immutability.md","articles":[]},{"title":"Visualize your data structures!","level":"3.1.2","depth":2,"path":"talks/Visualize.md","ref":"talks/Visualize.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["-fontsettings","github","youtube","image-wrapper","anchorjs"],"pluginsConfig":{"image-wrapper":{},"youtube":{},"github":{"url":"https://github.com/stanch/reftree"},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{"placement":"right","visible":"touch"}},"structure":{"langs":"LANGS.md","readme":"Overview.md","glossary":"GLOSSARY.md","summary":"Navigation.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"talks/Immutability.md","mtime":"2017-06-23T00:10:24.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-07-01T13:52:57.727Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    

    </body>
</html>

